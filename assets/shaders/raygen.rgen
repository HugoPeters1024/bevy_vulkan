#version 460
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "types.glsl"
#include "rand.glsl"
#include "common.glsl"
#include "disney.glsl"

layout(set=0, binding=0, rgba32f) uniform image2D render_target;
layout(set=0, binding=100)        uniform accelerationStructureEXT topLevelAS;
layout(set=1, binding=200)        uniform sampler2D textures[];


layout(push_constant, std430) uniform Registers {
  UniformData uniforms;
  MaterialData materials;
  BluenoiseData bluenoise;
  BluenoiseData unpacked_bluenoise;
  FocusData focus;
  uint skydome;
  uint _padding;
};

layout(location = 0) rayPayloadEXT HitPayload payload;
const uint SAMPLES = 8;
const uint MAX_BOUNCES = 64;

uint bbuffer(uint idx) {
  // extract the 8-bit value from the 32-bit buffer
  uint b = bluenoise.bluenoise[idx/4];
  b = (b >> (8 * (idx & 3))) & 0xFF;
  return b;
}


float bnoise(uint x, uint y, uint idx, uint dim)
{
    if (idx >= 16) { return randf(); }
    if (dim >= 8) { return randf(); }
    x &= 127, y &= 127;
    // xor index based on optimized ranking
    uint rankedIdx = (idx ^ bbuffer(dim + (x + y * 128) * 8 + 65536 * 3));
    // fetch value in sequence
    uint value = bbuffer(dim + rankedIdx * 256);
    // if the dimension is optimized, xor sequence value based on optimized scrambling
    value ^= bbuffer((dim & 7) + (x + y * 128) * 8 + 65536);
    // convert to float and return
    float r = (0.5f + value) * (1.0f / 256.0f);
    return r;
}


float bnoise3(uint x, uint y, uint idx, uint dim) {
  if (idx >= 64) { return randf(); }
  if (dim >= 4) { return randf(); }
  x &= 127, y &= 127;
  uint chunk_idx = idx * 128 * 128 + y * 128 + x;
  uint v = unpacked_bluenoise.bluenoise[chunk_idx];
  v = (v >> (8 * dim)) & 0xFF;
  return (float(v) + 0.5) / 256.0;
}

void main() {
  initRandom(gl_LaunchSizeEXT.xy, gl_LaunchIDEXT.xy, uniforms.tick);

  // wide screen
  if (float(gl_LaunchIDEXT.y) < gl_LaunchSizeEXT.y * 0.1 || float(gl_LaunchIDEXT.y) > gl_LaunchSizeEXT.y * 0.9) {
    imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), vec4(0.0));
    return;
  }



  const float tmin = 0.0001;
  const float tmax = 1000.0;

  vec3 acc = vec3(0.0);
  for (uint sample_idx = 0; sample_idx < SAMPLES; sample_idx += 1) {
    const vec2 pixel_center = vec2(gl_LaunchIDEXT.x, gl_LaunchSizeEXT.y - gl_LaunchIDEXT.y) + vec2(randf(), randf());
    const vec2 inUV = pixel_center / vec2(gl_LaunchSizeEXT.xy);
    const vec2 d = inUV * 2.0 - 1.0;

    const float offsetR = sqrt(randf());
    const float offsetA = randf() * 2.0f * PI;
    const vec2 offset = 0.002 * vec2(offsetR * cos(offsetA), offsetR * sin(offsetA));

    vec3 origin = (uniforms.inverse_view * vec4(0,0,0,1)).xyz;
    vec3 target = (uniforms.inverse_projection * vec4(d, 1, 1)).xyz;
    vec3 direction = (uniforms.inverse_view * vec4(normalize(target), 0)).xyz;

    if (uniforms.pull_focus_x == gl_LaunchIDEXT.x && uniforms.pull_focus_y == gl_LaunchIDEXT.y) {
      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);
      if (payload.t != 0.0) {
        focus.focal_distance = payload.t;
      }
    }

    vec3 focalPoint = origin + direction * focus.focal_distance;
    origin = (uniforms.inverse_view * vec4(offset, 0, 1)).xyz;
    direction = normalize(focalPoint - origin);

    vec3 mask = vec3(1.0);
    for (uint bounce_idx = 0; bounce_idx < MAX_BOUNCES; bounce_idx += 1) {
      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);

      if (payload.emission != vec3(0.0)) {
        acc += mask * payload.emission;
        break;
      }

      // miss
      if (payload.t == 0.0) {
        break;
      }

      origin = origin + direction * payload.t;
      if (randf() < 1-payload.color.a || max3(payload.color.rgb) == 0.0) {
        continue;
      }

      if (randf() < payload.transmission) {
        // calculate the eta based on whether we are inside
        const float n1 = payload.inside ? payload.refract_index : 1.0f;
        const float n2 = payload.inside ? 1.0f : payload.refract_index;
        const float eta = n1 / n2;

        const float costi = dot(payload.world_normal, -direction);
        const float k = 1 - (eta* eta) * (1 - costi * costi);


        float pReflect;
        if (k < 0) {
            // Total internal reflection
            pReflect = 1;
        } else {
            // fresnell equation for reflection contribution
            const float sinti = sqrt(max(0.0f, 1.0f - costi - costi));
            const float costt = sqrt(1.0f - eta * eta * sinti * sinti);
            const float spol = (n1 * costi - n2 * costt) / (n1 * costi + n2 * costt);
            const float ppol = (n1 * costt - n2 * costi) / (n1 * costt + n2 * costi);
            pReflect = 0.5f * (spol * spol + ppol * ppol);
        }

        vec3 refract_dir;
        if (randf() <= pReflect) {
            refract_dir = reflect(direction, payload.world_normal);
        } else {
            refract_dir = normalize(eta * direction + payload.world_normal * (eta * costi - sqrt(k)));
        }

        mat3 basis = orthogonalBasis(payload.world_normal);
        vec3 sample_dir = basis * CosineSampleHemisphere(randf(), randf());
        direction = mix(refract_dir, sample_dir, payload.roughness);
        if (payload.inside) {
          mask *= exp(-payload.t * payload.absorption);
        }
      } else {
        // russian roullete
        if (bounce_idx > 0) {
          const float pRussian = clamp(luma(payload.color.rgb), 0.1, 0.9);
          float r = bnoise3(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, uniforms.tick * SAMPLES + sample_idx, (bounce_idx-1) * 3 + 2);
          if (r >= pRussian) {
            break;
          }
          mask /= pRussian;
        }

        DisneyMaterial disney_mat = DisneyMaterial(
          payload.color.rgb, payload.metallic, payload.roughness
        );

        vec4 noise = vec4(
            bnoise3(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, uniforms.tick * SAMPLES + sample_idx, bounce_idx * 3 + 0),
            bnoise3(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, uniforms.tick * SAMPLES + sample_idx, bounce_idx * 3 + 1),
            randf(),
            randf()
        );

        // stratified sampling on the first bounce
        if (bounce_idx == 0) {
          noise.y = noise.y / SAMPLES + sample_idx / float(SAMPLES);
        }

        vec4 brdf = sampleDisneyBRDF(noise, -direction, payload.world_normal, disney_mat, direction);
        if (dot(direction, payload.surface_normal) < 0) {
          break;
        }

        // Note that an 'a' value of 0 does not mean that the bounce is impossible, but rather
        // that the bounce is a pure specular bounce.
        if (brdf.a > 0.0001) {
          mask *= brdf.rgb / brdf.a;
        }
      }
    }
  }


  vec4 prev;

  if (uniforms.accumulate == 0) {
    prev = vec4(0.0);
  } else {
    prev = imageLoad(render_target, ivec2(gl_LaunchIDEXT.xy));
  }

  imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), vec4(acc, SAMPLES) + prev);

  float v = 0.0;
  const float T = 4;
  for (uint i = 0; i < T; i++) {
    if (gl_LaunchIDEXT.x < gl_LaunchSizeEXT.x/2) {
      v += bnoise(gl_LaunchIDEXT.x/8, gl_LaunchIDEXT.y/8, i, 0);
    } else {
      v += bnoise3(gl_LaunchIDEXT.x/8, gl_LaunchIDEXT.y/8, i, 0);
    }
  }

  //imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), vec4(vec3(v/T), 1.0));
}

