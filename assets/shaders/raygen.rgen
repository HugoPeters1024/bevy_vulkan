#version 460
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "types.glsl"
#include "rand.glsl"
#include "common.glsl"

layout(set=0, binding=0, rgba32f) uniform image2D render_target;
layout(set=0, binding=1)          uniform accelerationStructureEXT topLevelAS;

layout(push_constant, std430) uniform Registers {
  UniformData uniforms;
};

layout(location = 0) rayPayloadEXT HitPayload payload;

const uint SAMPLES = 8;
const uint MAX_BOUNCES = 8;

void main() {
  initRandom(gl_LaunchSizeEXT.xy, gl_LaunchIDEXT.xy, uniforms.tick);


  const float tmin = 0.0001;
  const float tmax = 100.0;


  vec3 acc = vec3(0.0);
  for (uint i=0; i<SAMPLES; i++) {
    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(randf(), randf());
    const vec2 inUV = pixel_center / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec3 origin = (uniforms.inverse_view * vec4(0,0,0,1)).xyz;
    vec3 target = (uniforms.inverse_projection * vec4(d, 1, 1)).xyz;
    vec3 direction = (uniforms.inverse_view * vec4(normalize(target), 0)).xyz;


    vec3 mask = vec3(1.0);
    for (uint bounce = 0; bounce < MAX_BOUNCES; bounce++) {
      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);

      acc += mask * payload.emission;
      if (!payload.hit) { break; }

      mask *= payload.color;
      origin = origin + direction * payload.t * 0.999;
      direction = orthogonalBasis(payload.world_normal) * CosineSampleHemisphere(randf(), randf());
    }
  }


  acc = acc / float(SAMPLES);
  vec4 prev = imageLoad(render_target, ivec2(gl_LaunchIDEXT.xy));

  imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), vec4(acc, 1.0) + prev);
}

