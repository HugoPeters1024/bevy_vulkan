#version 460
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "types.glsl"
#include "rand.glsl"
#include "common.glsl"
#include "disney.glsl"

layout(set=0, binding=0, rgba32f) uniform image2D render_target;
layout(set=0, binding=1)          uniform accelerationStructureEXT topLevelAS;
layout(set=1, binding=42)         uniform sampler2D textures[];


layout(push_constant, std430) uniform Registers {
  UniformData uniforms;
  MaterialData materials;
  FocusData focus;
  uint skydome;
  uint _padding;
};

layout(location = 0) rayPayloadEXT HitPayload payload;
const uint SAMPLES = 8;
const uint MAX_BOUNCES = 32;

void main() {
  initRandom(gl_LaunchSizeEXT.xy, gl_LaunchIDEXT.xy, uniforms.tick);

  // wide screen
  if (float(gl_LaunchIDEXT.y) < gl_LaunchSizeEXT.y * 0.1 || float(gl_LaunchIDEXT.y) > gl_LaunchSizeEXT.y * 0.9) {
    imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), vec4(0.0));
    return;
  }

  const float tmin = 0.00001;
  const float tmax = 1000.0;

  vec3 acc = vec3(0.0);
  for (uint i=0; i<SAMPLES; i++) {
    const vec2 pixel_center = vec2(gl_LaunchIDEXT.x, gl_LaunchSizeEXT.y - gl_LaunchIDEXT.y) + vec2(randf(), randf());
    const vec2 inUV = pixel_center / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    const float offsetR = sqrt(randf());
    const float offsetA = randf() * 2.0f * PI;
    const vec2 offset = 0.005 * vec2(offsetR * cos(offsetA), offsetR * sin(offsetA));

    vec3 origin = (uniforms.inverse_view * vec4(0,0,0,1)).xyz;
    vec3 target = (uniforms.inverse_projection * vec4(d, 1, 1)).xyz;
    vec3 direction = (uniforms.inverse_view * vec4(normalize(target), 0)).xyz;

    if (uniforms.pull_focus_x == gl_LaunchIDEXT.x && uniforms.pull_focus_y == gl_LaunchIDEXT.y) {
      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);
      if (payload.hit) {
        focus.focal_distance = payload.t;
      }
    }

    vec3 focalPoint = origin + direction * focus.focal_distance;
    origin = (uniforms.inverse_view * vec4(offset, 0, 1)).xyz;
    direction = normalize(focalPoint - origin);


    vec3 mask = vec3(1.0);
    for (uint bounce = 0; bounce < MAX_BOUNCES; bounce++) {
      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);


      acc += mask * payload.emission;
      if (!payload.hit) { break; }


      float cFog = 0.00028f;
      float tFog = -log(1-randf()) / cFog;

      if (tFog < payload.t) {
          origin = origin + tFog * direction;
          direction = normalize(vec3(randf(), randf(), randf()) * 2.0 - 1.0);
          continue;
      }


      origin = origin + direction * payload.t;
      if (max3(payload.color) == 0.0) {
        continue;
      }



      mat3 basis = orthogonalBasis(payload.world_normal);

      if (randf() < payload.transmission) {
        // calculate the eta based on whether we are inside
        const float n1 = payload.inside ? payload.refract_index : 1.0f;
        const float n2 = payload.inside ? 1.0f : payload.refract_index;
        const float eta = n1 / n2;

        const float costi = dot(payload.world_normal, -direction);
        const float k = 1 - (eta* eta) * (1 - costi * costi);


        float pReflect;
        if (k < 0) {
            // Total internal reflection
            pReflect = 1;
        } else {
            // fresnell equation for reflection contribution
            const float sinti = sqrt(max(0.0f, 1.0f - costi - costi));
            const float costt = sqrt(1.0f - eta * eta * sinti * sinti);
            const float spol = (n1 * costi - n2 * costt) / (n1 * costi + n2 * costt);
            const float ppol = (n1 * costt - n2 * costi) / (n1 * costt + n2 * costi);
            pReflect = 0.5f * (spol * spol + ppol * ppol);
        }

        vec3 refract_dir;
        if (randf() <= pReflect) {
            refract_dir = reflect(direction, payload.world_normal);
        } else {
            refract_dir = normalize(eta * direction + payload.world_normal * (eta * costi - sqrt(k)));
        }

        vec3 sample_dir = basis * CosineSampleHemisphere(randf(), randf());
        direction = mix(refract_dir, sample_dir, payload.roughness);
        if (payload.inside) {
          mask *= exp(-payload.t * payload.absorption);
        }
      } else {
        // russian roullete
        const float pRussian = clamp(luma(payload.color.rgb), 0.1, 1.0);
        if (randf() > pRussian) {
          break;
        }
        mask /= pRussian;

        DisneyMaterial disney_mat = DisneyMaterial(
          payload.color, payload.metallic, payload.roughness, payload.emission
        );

        vec4 brdf = sampleDisneyBRDF(-direction, payload.world_normal, disney_mat, direction);
        if (brdf.a > 0.0001) {
          mask *= brdf.rgb / brdf.a;
        } else {
          break;
        }

        if (dot(direction, payload.surface_normal) < 0) {
          break;
        }
      }
    }
  }


  acc = acc / float(SAMPLES);
  vec4 prev = imageLoad(render_target, ivec2(gl_LaunchIDEXT.xy));

  if (uniforms.accumulate == 0) {
    prev = vec4(0.0);
  }

  imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), vec4(acc, 1.0) + prev);
}

