#version 460
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "types.glsl"
#include "rand.glsl"
#include "common.glsl"
#include "disney.glsl"

layout(set=0, binding=0, rgba32f) uniform image2D render_target;
layout(set=0, binding=100)        uniform accelerationStructureEXT topLevelAS;
layout(set=1, binding=200)        uniform sampler2D textures[];


layout(push_constant, std430) uniform Registers {
  UniformData uniforms;
  MaterialData materials;
  BluenoiseData bluenoise;
  BluenoiseData unpacked_bluenoise;
  FocusData focus;
  uint skydome;
  uint _padding;
};

layout(location = 0) rayPayloadEXT HitPayload payload;
const uint SAMPLES = 4;
const uint MAX_BOUNCES = 64;

uint bbuffer(uint idx) {
  // extract the 8-bit value from the 32-bit buffer
  uint b = bluenoise.bluenoise[idx/4];
  b = (b >> (8 * (idx & 3))) & 0xFF;
  return b;
}


float bnoise(uint x, uint y, uint idx, uint dim)
{
    if (idx >= 16) { return randf(); }
    if (dim >= 8) { return randf(); }
    x &= 127, y &= 127;
    // xor index based on optimized ranking
    uint rankedIdx = (idx ^ bbuffer(dim + (x + y * 128) * 8 + 65536 * 3));
    // fetch value in sequence
    uint value = bbuffer(dim + rankedIdx * 256);
    // if the dimension is optimized, xor sequence value based on optimized scrambling
    value ^= bbuffer((dim & 7) + (x + y * 128) * 8 + 65536);
    // convert to float and return
    float r = (0.5f + value) * (1.0f / 256.0f);
    return r;
}


uint g_bnoise3_dim = 0;
float bnoise3(uint x, uint y, uint idx) {
  if (idx >= 16) { return randf(); }
  uint dim = g_bnoise3_dim++;
  if (dim >= 8) { return randf(); }
  x &= 127, y &= 127;
  uint dim1 = dim / 4;
  uint dim2 = dim % 4;
  uint chunk_idx = idx * 128 * 128 + y * 128 + x + dim1 * 128 * 128 * 64;
  uint v = unpacked_bluenoise.bluenoise[chunk_idx];
  v = (v >> (8 * dim2)) & 0xFF;

  return (float(v) + 0.5) / 256.0;
}

float g_foginess = 0.000000001;
float g_extinction = 0.3;
float g_g = 0.99;

float sampleDistanceInFog() {
  return -log(randf()) / g_foginess;
}

float calcTransmittance(float distance) {
  return exp(-g_extinction * distance);
}

vec3 sampleScatterDirection(vec3 incoming) {
  // Henyey-Greenstein phase function sampling
  // g is the asymmetry parameter (-1 <= g <= 1)
  // g > 0 means forward scattering
  // g < 0 means backward scattering
  // g = 0 means isotropic scattering

  float g = g_g;
  float cosTheta;
  if (g == 0.0) {
    // isotropic
    cosTheta = 1.0 - 2.0 * randf();
  } else {
    // anisotropic
    float term = (1.0 - g * g) / (1.0 + g * (2.0 * randf() - 1.0));
    cosTheta = (1.0 + g * g - term * term) / (2.0 * g);
  }

  float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
  float phi = 2.0 * PI * randf();

  vec3 ret = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
  return orthonormalBasis(incoming) * ret;
}

void main() {
  initRandom(gl_LaunchSizeEXT.xy, gl_LaunchIDEXT.xy, uniforms.tick);

  // wide screen
  if (float(gl_LaunchIDEXT.y) < gl_LaunchSizeEXT.y * 0.1 || float(gl_LaunchIDEXT.y) > gl_LaunchSizeEXT.y * 0.9) {
    imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), vec4(0.0));
    return;
  }

  const float tmin = 0.0001;
  const float tmax = 1000.0;

  const vec2 pixel_center = vec2(gl_LaunchIDEXT.x, gl_LaunchSizeEXT.y - gl_LaunchIDEXT.y) + vec2(randf(), randf());
  const vec2 inUV = pixel_center / vec2(gl_LaunchSizeEXT.xy);
  const vec2 d = inUV * 2.0 - 1.0;

  const float offsetR = sqrt(randf());
  const float offsetA = randf() * 2.0f * PI;
  const vec2 offset = 0.002 * vec2(offsetR * cos(offsetA), offsetR * sin(offsetA));

  const vec3 initial_origin = (uniforms.inverse_view * vec4(0,0,0,1)).xyz;
  const vec3 target = (uniforms.inverse_projection * vec4(d, 1, 1)).xyz;
  const vec3 initial_direction = (uniforms.inverse_view * vec4(normalize(target), 0)).xyz;

  vec3 acc = vec3(0.0);
  for (uint sample_idx = 0; sample_idx < SAMPLES; sample_idx += 1) {
    vec3 origin = initial_origin;
    vec3 direction = initial_direction;

    if (uniforms.pull_focus_x == gl_LaunchIDEXT.x && uniforms.pull_focus_y == gl_LaunchIDEXT.y) {
      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);
      if (payload.t != 0.0) {
        focus.focal_distance = payload.t;
      }
    }

    vec3 focalPoint = origin + direction * focus.focal_distance;
    origin = (uniforms.inverse_view * vec4(offset, 0, 1)).xyz;
    direction = normalize(focalPoint - origin);

    vec3 mask = vec3(1.0);
    for (uint bounce_idx = 0; bounce_idx < MAX_BOUNCES; bounce_idx += 1) {
      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);

      // miss
      if (payload.t == 0.0) {
        acc += mask * payload.emission;
        break;
      }

      float fogDistance = sampleDistanceInFog();
      if (fogDistance < payload.t) {
        origin = origin + direction * fogDistance;
        mask *= calcTransmittance(fogDistance);
        direction = sampleScatterDirection(direction);
        continue;
      }
      if (payload.emission != vec3(0.0)) {
        acc += mask * payload.emission;
        break;
      }

      origin = origin + direction * payload.t;
      if (randf() < 1-payload.color.a || max3(payload.color.rgb) == 0.0) {
        continue;
      }

      if (randf() < payload.transmission) {
        // calculate the eta based on whether we are inside
        const float n1 = payload.inside ? payload.refract_index : 1.0f;
        const float n2 = payload.inside ? 1.0f : payload.refract_index;
        const float eta = n1 / n2;

        const float costi = dot(payload.world_normal, -direction);
        const float k = 1 - (eta* eta) * (1 - costi * costi);


        float pReflect;
        if (k < 0) {
            // Total internal reflection
            pReflect = 1;
        } else {
            // fresnell equation for reflection contribution
            const float sinti = sqrt(max(0.0f, 1.0f - costi - costi));
            const float costt = sqrt(1.0f - eta * eta * sinti * sinti);
            const float spol = (n1 * costi - n2 * costt) / (n1 * costi + n2 * costt);
            const float ppol = (n1 * costt - n2 * costi) / (n1 * costt + n2 * costi);
            pReflect = 0.5f * (spol * spol + ppol * ppol);
        }

        vec3 refract_dir;
        if (randf() <= pReflect) {
            refract_dir = reflect(direction, payload.world_normal);
        } else {
            refract_dir = normalize(eta * direction + payload.world_normal * (eta * costi - sqrt(k)));
        }

        mat3 basis = orthonormalBasis(payload.world_normal);
        vec3 sample_dir = basis * CosineSampleHemisphere(randf(), randf());
        direction = mix(refract_dir, sample_dir, payload.roughness);
        if (payload.inside) {
          mask *= exp(-payload.t * payload.absorption);
        }
      } else {
        // russian roullete
        if (bounce_idx > 0) {
          const float pRussian = clamp(luma(payload.color.rgb), 0.1, 0.9);
          float r = bounce_idx <= 2 ? bnoise3(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, uniforms.tick * SAMPLES + sample_idx) : randf();
          if (r >= pRussian) {
            break;
          }
          mask /= pRussian;
        }

        DisneyMaterial disney_mat = DisneyMaterial(
          payload.color.rgb, payload.metallic, payload.roughness
        );

        vec4 noise = vec4(
            bounce_idx <= 1 ? bnoise3(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, uniforms.tick * SAMPLES + sample_idx) : randf(),
            bounce_idx <= 1 ? bnoise3(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, uniforms.tick * SAMPLES + sample_idx) : randf(),
            randf(),
            randf()
        );

        // stratified sampling on the first bounce
        if (bounce_idx == 0) {
          if (SAMPLES == 16) {
            float range_x = (sample_idx % 4) / 4.0;
            float range_y = (sample_idx / 4) / 4.0;
            noise.x = noise.x / 4.0 + range_x;
            noise.y = noise.y / 4.0 + range_y;
          } else {
            noise.y = noise.y / SAMPLES + sample_idx / float(SAMPLES);
          }
        }


        vec4 brdf = sampleDisneyBRDF(noise, -direction, payload.world_normal, disney_mat, direction);
        if (dot(direction, payload.surface_normal) < 0) {
          break;
        }

        // Note that an 'a' value of 0 does not mean that the bounce is impossible, but rather
        // that the bounce is a pure specular bounce.
        if (brdf.a > 0.0001) {
          mask *= brdf.rgb / brdf.a;
        }
      }
    }
  }


  vec4 prev;

  if (uniforms.accumulate == 0) {
    prev = vec4(0.0);
  } else {
    prev = imageLoad(render_target, ivec2(gl_LaunchIDEXT.xy));
  }

  imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), vec4(acc, SAMPLES) + prev);
}

